{% extends 'base_admin.html.twig' %}

{% block title %}{{ 'card.list.title'|trans }} - Hermio{% endblock %}

{% block page_title %}{{ 'card.list.title'|trans }}{% endblock %}

{% block admin_content %}
<div class="container" style="padding-bottom: 3rem;">
    <div class="card">
        <div class="card-header">
            <div class="row align-items-center">
                <div class="col-md-6 col-12">
                    <h2>{{ 'card.list.title'|trans }}</h2>
                    <p class="mb-0">
                        <strong>{{ 'account.quota.usage'|trans }}:</strong>
                        {{ currentUsage }} /
                        {% if quotaLimit %}
                            {{ quotaLimit }} {{ 'account.quota.cards'|trans }}
                        {% else %}
                            {{ 'account.quota.unlimited'|trans }}
                        {% endif %}
                    </p>
                </div>
                <div class="col-md-6 col-12 mt-2 mt-md-0">
                    {% if canCreateMore %}
                        <div class="d-flex justify-content-end">
                            <a href="{{ path('app_card_create') }}" class="btn btn-primary">{{ 'card.create.button'|trans }}</a>
                        </div>
                    {% else %}
                        <div class="alert alert-warning mb-0">
                            {{ 'card.quota.exceeded'|trans }}
                            <a href="{{ path('app_account_my_plan') }}">{{ 'account.view_plan_details'|trans }}</a>
                        </div>
                    {% endif %}
                </div>
            </div>
        </div>
    </div>

    {# Search Bar #}
    {% if totalCards > 0 %}
        <div class="card mt-3">
            <div class="card-body">
                <div class="row align-items-center">
                    <div class="col-md-8 col-12">
                        <div class="position-relative">
                            <i class="fas fa-search position-absolute" style="left: 12px; top: 50%; transform: translateY(-50%); color: #6c757d; z-index: 2;"></i>
                            <input type="text"
                                   id="card-search"
                                   class="form-control ps-5 pe-5"
                                   placeholder="{{ 'card.search.placeholder'|trans|default('Search cards by name, email, or company...') }}"
                                   aria-label="{{ 'card.search.label'|trans|default('Search cards') }}"
                                   style="user-select: text !important; caret-color: auto !important; cursor: text !important;">
                            <div id="search-spinner" class="position-absolute" style="right: 12px; top: 50%; transform: translateY(-50%); display: none; z-index: 2;">
                                <div class="spinner-border spinner-border-sm text-primary" role="status">
                                    <span class="visually-hidden">Loading...</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-4 col-12 mt-2 mt-md-0">
                        <span id="card-count" class="text-muted">
                            {{ 'card.count'|trans|default('Total cards') }}: <strong id="card-total">{{ totalCards }}</strong>
                        </span>
                    </div>
                </div>
            </div>
        </div>
    {% endif %}

    {# Cards Container #}
    <div class="row" id="cards-container">
        {% if cards|length > 0 %}
            {% include 'card/_card_list.html.twig' %}
        {% else %}
            <div class="col-12 mt-4">
                <div class="alert alert-info" id="no-cards-message">
                    <p>{{ 'card.list.empty'|trans }}</p>
                    {% if canCreateMore %}
                        <a href="{{ path('app_card_create') }}" class="btn btn-primary">{{ 'card.create.button'|trans }}</a>
                    {% endif %}
                </div>
            </div>
        {% endif %}
    </div>

    {# Loading Indicator #}
    <div class="text-center mt-4" id="loading-indicator" style="display: none;">
        <div class="spinner-border text-primary" role="status">
            <span class="visually-hidden">{{ 'common.loading'|trans|default('Loading...') }}</span>
        </div>
    </div>

    {# No Results Message Template (hidden) #}
    <div id="no-results-template" style="display: none;">
        <div class="col-12 mt-4">
            <div class="alert alert-info">
                <p>{{ 'card.search.no_results'|trans|default('No cards found matching your search.') }}</p>
            </div>
        </div>
    </div>

    {# Infinite Scroll Trigger #}
    <div id="scroll-trigger" style="height: 1px;" data-offset="{{ cards|length }}" data-has-more="{{ totalCards > cards|length ? 'true' : 'false' }}"></div>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const searchInput = document.getElementById('card-search');
    const searchSpinner = document.getElementById('search-spinner');
    const cardsContainer = document.getElementById('cards-container');
    const scrollTrigger = document.getElementById('scroll-trigger');
    const loadingIndicator = document.getElementById('loading-indicator');
    const cardTotal = document.getElementById('card-total');
    const noResultsTemplate = document.getElementById('no-results-template');
    const apiUrl = {{ path('app_card_api_search')|json_encode|raw }};

    let currentQuery = '';
    let currentOffset = 0;
    let hasMore = scrollTrigger ? scrollTrigger.dataset.hasMore === 'true' : false;
    let isLoading = false;
    let searchTimeout = null;

    // Add CSS animations
    const style = document.createElement('style');
    style.textContent = `
        /* Force input to be interactive */
        #card-search {
            user-select: text !important;
            caret-color: auto !important;
            cursor: text !important;
            pointer-events: auto !important;
            position: relative !important;
            z-index: 10 !important;
        }

        #card-search:focus {
            outline: 2px solid #0d6efd !important;
            outline-offset: -2px !important;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .card-item {
            animation: fadeInUp 0.4s ease-out;
        }

        .card-item:nth-child(even) {
            animation-delay: 0.1s;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.5;
            }
        }

        .skeleton-loader {
            animation: pulse 1.5s ease-in-out infinite;
            background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% {
                background-position: -200% 0;
            }
            100% {
                background-position: 200% 0;
            }
        }
    `;
    document.head.appendChild(style);

    // Search functionality with debounce
    if (searchInput) {
        searchInput.addEventListener('input', function() {
            clearTimeout(searchTimeout);

            // Show spinner immediately when typing
            if (searchSpinner && searchInput.value.trim() !== '') {
                searchSpinner.style.display = 'block';
            }

            searchTimeout = setTimeout(function() {
                currentQuery = searchInput.value.trim();
                currentOffset = 0;
                hasMore = true;
                loadCards(true);
            }, 300); // 300ms debounce
        });
    }

    // Infinite scroll
    if (scrollTrigger) {
        const observer = new IntersectionObserver(function(entries) {
            entries.forEach(function(entry) {
                if (entry.isIntersecting && hasMore && !isLoading) {
                    loadCards(false);
                }
            });
        }, {
            rootMargin: '100px'
        });

        observer.observe(scrollTrigger);
    }

    // Create skeleton loaders for smooth loading experience
    function createSkeletonLoaders(count) {
        let html = '';
        for (let i = 0; i < count; i++) {
            html += `
                <div class="col-6 mt-4">
                    <div class="card">
                        <div class="card-header bg-light">
                            <div class="skeleton-loader" style="height: 24px; width: 60%; border-radius: 4px;"></div>
                        </div>
                        <div class="card-body">
                            <div class="skeleton-loader mb-3" style="height: 20px; width: 100%; border-radius: 4px;"></div>
                            <div class="skeleton-loader mb-3" style="height: 20px; width: 80%; border-radius: 4px;"></div>
                            <div class="skeleton-loader mb-3" style="height: 20px; width: 40%; border-radius: 4px;"></div>
                            <div class="d-flex gap-2 mt-3">
                                <div class="skeleton-loader" style="height: 38px; flex: 1; border-radius: 8px;"></div>
                                <div class="skeleton-loader" style="height: 38px; flex: 1; border-radius: 8px;"></div>
                                <div class="skeleton-loader" style="height: 38px; flex: 1; border-radius: 8px;"></div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        return html;
    }

    function loadCards(replace) {
        if (isLoading) return;

        isLoading = true;

        // Show spinner in search input
        if (searchSpinner && currentQuery) {
            searchSpinner.style.display = 'block';
        }

        if (loadingIndicator) {
            loadingIndicator.style.display = 'block';
        }

        // Add skeleton loaders for better UX
        if (replace) {
            cardsContainer.innerHTML = createSkeletonLoaders(2);
        }

        const url = new URL(apiUrl, window.location.origin);
        if (currentQuery) {
            url.searchParams.set('q', currentQuery);
        }
        if (!replace) {
            url.searchParams.set('offset', currentOffset);
        }

        fetch(url)
            .then(function(response) {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.text();
            })
            .then(function(html) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const newCards = doc.querySelectorAll('.card-item');

                if (replace) {
                    cardsContainer.innerHTML = '';
                    currentOffset = 0;
                }

                if (newCards.length > 0) {
                    newCards.forEach(function(card, index) {
                        // Add staggered animation delay
                        card.style.animationDelay = (index * 0.05) + 's';
                        cardsContainer.appendChild(card);
                    });
                    currentOffset += newCards.length;
                } else if (replace) {
                    // No results - clone and append the no results template
                    if (noResultsTemplate) {
                        const noResults = noResultsTemplate.cloneNode(true);
                        noResults.style.display = '';
                        noResults.id = '';
                        cardsContainer.appendChild(noResults.firstElementChild);
                    }
                }

                // Update hasMore flag
                const hasMoreAttr = doc.querySelector('[data-has-more]');
                hasMore = hasMoreAttr ? hasMoreAttr.dataset.hasMore === 'true' : false;

                // Update total count with animation
                const totalAttr = doc.querySelector('[data-total-cards]');
                if (totalAttr && cardTotal) {
                    const newTotal = totalAttr.dataset.totalCards;
                    if (cardTotal.textContent !== newTotal) {
                        cardTotal.style.transition = 'all 0.3s ease';
                        cardTotal.style.transform = 'scale(1.2)';
                        cardTotal.style.color = '#0d6efd';
                        setTimeout(function() {
                            cardTotal.textContent = newTotal;
                            setTimeout(function() {
                                cardTotal.style.transform = 'scale(1)';
                                cardTotal.style.color = '';
                            }, 100);
                        }, 150);
                    }
                }

                // Hide spinners with smooth transition
                if (loadingIndicator) {
                    loadingIndicator.style.display = 'none';
                }

                if (searchSpinner) {
                    setTimeout(function() {
                        searchSpinner.style.display = 'none';
                    }, 300);
                }

                isLoading = false;
            })
            .catch(function(error) {
                console.error('Error loading cards:', error);
                if (loadingIndicator) {
                    loadingIndicator.style.display = 'none';
                }
                if (searchSpinner) {
                    searchSpinner.style.display = 'none';
                }
                isLoading = false;
            });
    }
});
</script>

{# Diagnostic script for debugging sidebar issues #}
<script>
document.addEventListener('DOMContentLoaded', function() {
    console.log('[DEBUG] Testing card-search accessibility');
    const searchInput = document.getElementById('card-search');
    const sidebar = document.getElementById('adminSidebar');

    if (searchInput && sidebar) {
        const inputRect = searchInput.getBoundingClientRect();
        const sidebarRect = sidebar.getBoundingClientRect();
        const sidebarStyles = window.getComputedStyle(sidebar);

        console.log('[DEBUG] Search Input:', {
            left: inputRect.left,
            top: inputRect.top,
            width: inputRect.width,
            height: inputRect.height,
            zIndex: window.getComputedStyle(searchInput).zIndex,
            pointerEvents: window.getComputedStyle(searchInput).pointerEvents
        });

        console.log('[DEBUG] Sidebar:', {
            left: sidebarRect.left,
            top: sidebarRect.top,
            width: sidebarRect.width,
            transform: sidebarStyles.transform,
            visibility: sidebarStyles.visibility,
            pointerEvents: sidebarStyles.pointerEvents,
            zIndex: sidebarStyles.zIndex,
            hasShowClass: sidebar.classList.contains('show')
        });

        // Check if sidebar overlaps input
        const overlaps = !(inputRect.right < sidebarRect.left ||
                          inputRect.left > sidebarRect.right ||
                          inputRect.bottom < sidebarRect.top ||
                          inputRect.top > sidebarRect.bottom);

        console.log('[DEBUG] Sidebar overlaps input:', overlaps);

        if (overlaps && sidebarStyles.pointerEvents !== 'none') {
            console.warn('[DEBUG] ⚠️ PROBLEM: Sidebar overlaps input and has pointer-events:', sidebarStyles.pointerEvents);
        } else {
            console.log('[DEBUG] ✅ Input should be accessible');
        }

        // NEW: Test what element is actually at the input position
        const centerX = inputRect.left + inputRect.width / 2;
        const centerY = inputRect.top + inputRect.height / 2;
        const elementAtPoint = document.elementFromPoint(centerX, centerY);

        console.log('[DEBUG] Element at input center point:', {
            element: elementAtPoint,
            tagName: elementAtPoint?.tagName,
            id: elementAtPoint?.id,
            className: elementAtPoint?.className,
            isInputItself: elementAtPoint === searchInput
        });

        if (elementAtPoint !== searchInput) {
            console.error('[DEBUG] ❌ BLOCKER FOUND: Element blocking input:', elementAtPoint);
            console.error('[DEBUG] Blocker styles:', {
                zIndex: window.getComputedStyle(elementAtPoint).zIndex,
                position: window.getComputedStyle(elementAtPoint).position,
                pointerEvents: window.getComputedStyle(elementAtPoint).pointerEvents,
                background: window.getComputedStyle(elementAtPoint).background
            });
        } else {
            console.log('[DEBUG] ✅ Input is the top element at its position');
        }

        // Test if input can actually be focused
        console.log('[DEBUG] Testing focus capability...');
        console.log('[DEBUG] Input attributes:', {
            disabled: searchInput.disabled,
            readOnly: searchInput.readOnly,
            tabIndex: searchInput.tabIndex,
            type: searchInput.type
        });

        // Try to focus the input
        searchInput.focus();

        setTimeout(function() {
            console.log('[DEBUG] After focus attempt:', {
                hasFocus: document.activeElement === searchInput,
                activeElement: document.activeElement,
                inputValue: searchInput.value
            });

            if (document.activeElement !== searchInput) {
                console.error('[DEBUG] ❌ INPUT CANNOT RECEIVE FOCUS!');
                console.error('[DEBUG] Active element is:', document.activeElement);

                // Try to force focus with click
                console.log('[DEBUG] Trying to force focus with click...');
                searchInput.click();

                setTimeout(function() {
                    console.log('[DEBUG] After click:', {
                        hasFocus: document.activeElement === searchInput,
                        activeElement: document.activeElement
                    });
                }, 100);
            } else {
                console.log('[DEBUG] ✅ Input successfully focused');
            }
        }, 100);
    }
});
</script>
{% endblock %}

